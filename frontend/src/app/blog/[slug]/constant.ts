export const data =
  '# Overview\n\nIn recent years, blockchain networks have grown exponentially. Looking at the Ethereum ecosystem alone, there are now more than 50 different chains. While this growth brings more opportunities, it also creates challenges for users. Managing funds across multiple chains and maintaining sufficient gas fees for transactions on each network has become increasingly complex.\n\nThis is where Squid comes to the rescue. As a cross-chain platform, Squid specializes in enabling token transfers between the Ethereum and Cosmos ecosystems. Their recently released SDK takes this functionality a step further by allowing cross-chain smart contract calls. This means developers can now program specific actions to occur before or after tokens are bridged, unlocking new possibilities in the DeFi ecosystem.\n\n# Understanding Hooks in Squid\n\nBefore we start writing the code, let’s look at how this works -\n\nAt the heart of Squid\'s system are "hooks" - specialized functions that enable smart contract execution. These hooks can be triggered either before or after a token swap/bridging occurs.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1731904702899/06e2bf5f-0166-453f-b738-5137cc6e6014.png align="center")\n\nPre Hooks are executed before the swap/bridging occurs and Post Hooks are executed after the swap/bridging has occured.\n\nFor example - Pre Hooks can come in handy when you need to perform some operations on chain before performing the swap such as withdrawing any asset from aave by supplying the aToken and receiving the underlying token and then you can bridge the underlying token using squid, all in one transaction. Crazy, right?\n\n# Implementation\n\nOkay, enough talking. Let’s see it in action. We will be implementing depositing into aave protocol in this tutorial.\n\nIn order to enable cross-chain transactions, we obviously need to install squid-sdk into our next project. You can do so by running the following command.\n\n```javascript\nnpm install @0xsquid/sdk @0xsquid/squid-types\n```\n\nWe will also need ethers.js library, so let’s download that as well.\n\n```typescript\nnpm i ethers@5\n```\n\nOk, let’s setup the squid config first of all. Create a file `config/squid.ts` to setup the squid config by pasting the below code.\n\n```typescript\nimport { Squid } from \'@0xsquid/sdk\';\n\nexport const squidConfig = async () => {\n  const squid = new Squid({\n    baseUrl: "https://v2.api.squidrouter.com",\n    integratorId: process.env.NEXT_PUBLIC_SQUID_INTEGRATOR_ID as string,\n    executionSettings: {\n      infiniteApproval: false,\n    },\n  });\n\n  await squid.init();\n\n  return squid;\n};\n```\n\nIn order to get the *INTEGRATOR\\_ID, you can fill up the form* [*here*](https://form.typeform.com/to/cqFtqSvX?typeform-source=docs.squidrouter.com)*.*\n\nNow, let’s declare the argument type for our function. Paste the code below in `types/squid.ts`.\n\n```typescript\nimport { Hook } from "@0xsquid/squid-types";\n\nexport type TSquidQouteArgs = {\n  fromChain: string;\n  toChain: string;\n  fromAmount: string;\n  fromToken: string;\n  toToken: string;\n  fromAddress: string;\n  toAddress: string;\n  receiveGasOnDestination: boolean;\n  slippage?: number;\n  preHook?: Hook;\n  postHook?: Hook;\n};\n```\n\nNext up, create a file `tools/squid.ts` inside your src folder, this is where we will use squid to fetch the route of the transaction.\n\n```typescript\nimport { squidConfig } from "@/config/squid";\nimport { TSquidQouteArgs } from "@/types/squid";\nimport { RouteRequest } from "@0xsquid/squid-types";\n\nexport async function createQuote(squidQuoteArgs: TSquidQouteArgs) {\n  try {\n    const squid = await squidConfig();\n\n    const config: RouteRequest = {\n      fromChain: squidQuoteArgs.fromChain,\n      fromAmount: squidQuoteArgs.fromAmount,\n      fromToken: squidQuoteArgs.fromToken,\n      toChain: squidQuoteArgs.toChain,\n      toToken: squidQuoteArgs.toToken,\n      fromAddress: squidQuoteArgs.fromAddress,\n      toAddress: squidQuoteArgs.toAddress,\n      receiveGasOnDestination: squidQuoteArgs.receiveGasOnDestination,\n      enableBoost: true,\n    };\n\n    if (squidQuoteArgs?.slippage) {\n      config.slippage = squidQuoteArgs.slippage;\n    }\n\n    if (squidQuoteArgs.preHook) {\n      config.preHook = squidQuoteArgs.preHook;\n    }\n\n    if (squidQuoteArgs.postHook) {\n      config.postHook = squidQuoteArgs.postHook;\n    }\n\n    const { route } = await squid.getRoute(config);\n\n    return route;\n  } catch (error) {\n    console.log(error);\n  }\n}\n```\n\nAlthough most of these fields are pretty self explanatory, I will explain them one by one for a better understanding.\n\nFirst of all, we initialize Squid’s SDK by calling the `squidConfig` function which returns the squid instance.\n\nNow, we need to setup the parameters which are needed in order to get the route, these parameters are -\n\n`fromChain` - the chain Id of the chain from which we will be sending the transaction.\n\n`fromAmount` - the amount which will be sent from the source chain or fromChain. Remember this amount should be in wei.\n\n`fromToken` - the token that user will send from the source chain.\n\n`toChain` - the chain Id of the destination chain\n\n`fromAddress` - the address of the EOA wallet that will be sending the funds from the source chain.\n\n`toAddress` - the address of the EOA wallet that will receive the funds on destination chain.\n\n`receiveGasOnDestination` - if toAddress should recieve some gas on the destination chain, defaults to false.\n\n`slippage` - slippage is an optional field and specifies how much slippage should occur at max while swapping/bridging\n\n`preHook` - preHook is also optional and specifies the code that should be executed onChain before the swap/bridging happens.\n\n`postHook` - postHook is another optional field same as preHook that specifies the code that should be executed after the swap/bridging has happened.\n\nOk, now that we have setup the getRoute function, let’s see how we can create preHook and postHook where the real magic actually happens.\n\nWe will create a function called `hookBuilder` which will be responsibe for creating the hook i.e postHook or preHook. So, first of all let’s create type for the arguments that we will be passing into the function. Modify `types/squid.ts` with the following code.\n\n```typescript\n/*......*/\nimport {SquidCallType} from "@0xsquid/squid-types";\n\n/*......*/\nexport type HookBuilderArgs = {\n  fundToken: string;\n  fundAmount: string;\n  description: string;\n  calls: {\n    target: string;\n    callType: SquidCallType;\n    callData: string;\n    payload?: {\n      tokenAddress: string;\n      inputPos: number;\n    };\n    estimatedGas?: string;\n  }[];\n};\n```\n\nNow, create a file `utils/hook-builder/index.ts` and paste the following code.\n\n```typescript\nimport { ChainType, Hook } from "@0xsquid/squid-types";\nimport { HookBuilderArgs } from "@/types/squid";\n\nexport const hookBuilder = (hookBuilderArgs: HookBuilderArgs): Hook => {\n  const hook: Hook = {\n    chainType: ChainType.EVM,\n    fundToken: hookBuilderArgs.fundToken,\n    fundAmount: hookBuilderArgs.fundAmount,\n    description: hookBuilderArgs.description,\n    calls: hookBuilderArgs.calls.map((call) => {\n      return {\n        chainType: ChainType.EVM,\n        callType: call.callType,\n        target: call.target,\n        callData: call.callData,\n        estimatedGas: "4000000",\n        value: "0",\n        payload: call.payload,\n      };\n    }),\n    provider: "Your app name",\n    logoURI: "your logo url",\n  };\n\n  return hook;\n};\n```\n\nNotice, that this file is written based on our specific use case and you are free to modify the parameteres such as `value` or `estimatedGas` as per your needs.\n\nLet’s understand the parameters one by one -\n\n`chainType` - chainType mentions the type of transaction, is it of type cosmos or evm.\n\n`fundToken` - fundToken is the token that we take from user, whereas fromToken is the one which will be swapped or bridged. This comes in handy when you use preHook and you want to send aToken to squid, perform some preHook operation and then bridge the underlying token. In that case aToken will be the fundToken and underlying token will be the fromToken.\n\n`fundAmount` - the amount of fundToken that should be sent.\n\n`description` - description of the transaction.\n\n`calls` - calls is basically an array of smart contract calls that you want to execute before or after the swap/bridging happens.\n\n`callType` - Well, basically there are 3 types of callType that you will be using. `DEFAULT`, `FULL_TOKEN_BALANCE` and `FULL_NATIVE_BALANCE`. Let’s take an example to understand them better - Let’s say I am sending 10 USDC from base and I want USDT on arbitrum and I want to use postHook to deposit all the amount to aave. But I don’t really know how much USDT I will receive on destination chain because of the slippage. So, I can’t really make a smart contract call out of it mentioning that I want to deposit x amount of USDT. To solve this, we can use `FULL_TOKEN_BALANCE` to alter the callData in flight with the amount that I will receive after bridging/swapping. This is used in relation with payload that we will see later.\n\n`target` - target is the address of the smart contract or EOA that I want to make this smart contract call to.\n\n`callData` - callData is the encoded function data in the form of bytes that we want to execute.\n\n`estimatedGas` - the gas required to execute this function call.\n\n`value` - value in terms of ETH that we want to pass to the function call.\n\n`payload` - payload is used when we are using `FULL_TOKEN_BALANCE` or `FULL_NATIVE_BALANCE`. payload needs two things - the token that we want to modify the value of and the argument index value where the value should be modified.\n\nWith that done, we are down to our last steps which is setting up the deposit call for aave. So, let’s do this.\n\nWe will be interacting with aave pool contract. So, we need to ABI of that and the ABI of erc20 token. You can fetch those details from aave official docs. So, we will be skipping that.\n\nYou also need the contract address of the aave pool contract. Okay, so with that being done. Create a file for type of the deposit function arguments named `types/transcation.ts`\n\n```typescript\nimport { TSquidQouteArgs } from "./squid";\n\nexport type TTransactionPayload = TSquidQouteArgs & {\n  fundToken: string;\n  fundAmount: string;\n};\n```\n\nOk, let’s setup `supplyHandler` in `libs/aave/index.ts`.\n\n```typescript\nimport { POOL_ADDRESS } from "@/constants";\nimport { AAVE_POOL_ABI, ERC20_ABI } from "@/constants/abi";\nimport { HookBuilderArgs } from "@/types/squid";\nimport { TTransactionPayload } from "@/types/transaction";\nimport { hookBuilder } from "@/utils/hook-builder";\nimport { Hook, SquidCallType } from "@0xsquid/squid-types";\nimport { ethers } from "ethers";\n\nexport const supplyHandler = async (txDetails: TTransactionPayload): Promise<Hook> => {\n  const calls: HookBuilderArgs["calls"] = [];\n\n  const erc20Interface = new ethers.utils.Interface(ERC20_ABI);\n\n  const approveCall = erc20Interface.encodeFunctionData(\n    "approve",\n    [POOL_ADDRESS, 1] //* the value at first index gets overwritten by payload\n  );\n\n  calls.push({\n    target: txDetails.toToken,\n    callType: SquidCallType.FULL_TOKEN_BALANCE,\n    callData: approveCall,\n    payload: {\n      tokenAddress: txDetails.toToken,\n      inputPos: 1,\n    },\n  });\n\n  const aaveSupplyInterface = new ethers.utils.Interface(AAVE_POOL_ABI);\n\n  const supplyCall = aaveSupplyInterface.encodeFunctionData("supply", [txDetails.toToken, 1, txDetails.fromAddress, 0]);\n\n  calls.push({\n    target: POOL_ADDRESS,\n    callType: SquidCallType.FULL_TOKEN_BALANCE,\n    callData: supplyCall,\n    payload: {\n      tokenAddress: txDetails.toToken,\n      inputPos: 1,\n    },\n  });\n\n  const hooks = hookBuilder({\n    fundToken: txDetails.fromToken,\n    fundAmount: txDetails.fromAmount,\n    description: "Supply",\n    calls,\n  });\n\n  return hooks;\n};\n```\n\nOk, everything done. Now we just have to call the methods to get the route and execute it. You can do it as per your needs but for demo purposes, I will be doing it in the home page itself.\n\n```typescript\n"use client";\n\nimport { squidConfig } from "@/config/squid";\nimport { supplyHandler } from "@/libs/aave";\nimport { createQuote } from "@/tools/squid";\nimport { TTransactionPayload } from "@/types/transaction";\nimport { ethers } from "ethers";\n\nexport default function Home() {\n  const supply = async () => {\n    const transactionPayload: TTransactionPayload = {\n      fromChain: "42161",\n      toChain: "8453",\n      fundToken: "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1", //WETH on arbitrum\n      fundAmount: "10000000000000000", //0.01 WETH\n      fromAmount: "10000000000000000", //0.01 WETH\n      fromToken: "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1", //WETH on arbitrum\n      toToken: "0x4200000000000000000000000000000000000006", //WETH on base\n      fromAddress: "0x0f4e3b1f3d6a9f9c8d3f7d0a3c0c3a2b1a090807", //user address\n      toAddress: "0x0f4e3b1f3d6a9f9c8d3f7d0a3c0c3a2b1a090807", //user address\n      receiveGasOnDestination: false,\n    };\n\n    const postHook = await supplyHandler(transactionPayload);\n\n    const route = await createQuote({ ...transactionPayload, postHook });\n\n    if (!route) return;\n\n    const squid = await squidConfig();\n\n    const provider = new ethers.providers.Web3Provider(window.ethereum, "any");\n\n    const signer = provider.getSigner();\n\n    await squid.executeRoute({ signer, route });\n  };\n\n  return (\n    <>\n      <button onClick={supply}>\n        Execute\n      </button>\n    </>\n  );\n}\n```\n\nAnd that’s it🎉🎉. Now you can successfully execute any smart contract from any chain and build anything you want.\n\n## Support me ⭐\n\nIf you found this tutorial helpful, consider sharing it with your friends. Thank you for reading, and I wish you a great time!\n\nFeel free to connect with me on [Twitter](https://twitter.com/itsz_vaibhav), [Github](https://github.com/VaibhavArora19) or [Linkedin](https://www.linkedin.com/in/vaibhav-arora-5234301a0/). I Would love to hear your feedback.\n\nHappy learning 👋';
